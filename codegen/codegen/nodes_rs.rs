use lib_ruby_parser_nodes::template::*;

const TEMPLATE: &str = "// This file is autogenerated by {{ helper generated-by }}

use wasm_bindgen::prelude::*;
use crate::{IntoJs, JsLoc, JsBytes};

{{ each node }}<dnl>
#[wasm_bindgen]
extern \"C\" {
    #[wasm_bindgen(js_name = {{ helper node-camelcase-name }})]
    pub type Js{{ helper node-camelcase-name }};

    #[wasm_bindgen(constructor, js_namespace = nodes, js_class = {{ helper node-camelcase-name }})]
    fn new(
{{ each node-field }}<dnl>
        {{ helper node-field-name }}: {{ helper node-field-js-type }},
{{ end }}<dnl>
    ) -> Js{{ helper node-camelcase-name }};
}
use lib_ruby_parser::nodes::{{ helper node-camelcase-name }} as Rust{{ helper node-camelcase-name }};
impl IntoJs for Rust{{ helper node-camelcase-name }} {
    type Output = Js{{ helper node-camelcase-name }};
    fn into_js(self) -> Js{{ helper node-camelcase-name }} {
        Js{{ helper node-camelcase-name }}::new(
{{ each node-field }}<dnl>
            self.{{ helper node-field-name }}.into_js(),
{{ end }}<dnl>
        )
    }
}
{{ end }}<dnl>

#[wasm_bindgen]
extern \"C\" {
    #[wasm_bindgen(js_name = Node)]
    pub type JsNode;

    #[wasm_bindgen(constructor, js_class = Node)]
    fn new(v: JsValue) -> JsNode;
}
use lib_ruby_parser::Node as RustNode;
impl IntoJs for RustNode {
    type Output = JsNode;
    fn into_js(self) -> JsNode {
        match self {
{{ each node }}<dnl>
            Self::{{ helper node-camelcase-name }}(inner) => {
                let js_inner: Js{{ helper node-camelcase-name }} = inner.into_js();
                JsNode::from(JsValue::from(js_inner))
            },
{{ end }}<dnl>
        }
    }
}
";

pub(crate) fn codegen() {
    let template = TemplateRoot::new(TEMPLATE).unwrap();
    let fns = crate::codegen::fns::default_fns!();

    let contents = template.render(ALL_DATA, &fns);
    std::fs::write("../bindings/src/nodes.rs", contents).unwrap();
}
